[TOC]



#### 11.5  js高级

##### 面向对象

![image-20221105143043032](js高级.assets/image-20221105143043032.png)



将问题分解成对象化，并使用对象的功能去解决问题



##### 面向过程和面向对象的优缺点

![image-20221105143209852](js高级.assets/image-20221105143209852.png)



![image-20221105143239262](js高级.assets/image-20221105143239262.png)s





# 续学

## Es6 新特性

![image-20230530161607720](js高级.assets/image-20230530161607720.png)



## var、 let、  const  

var为es5中，预编译， 可重复定义

let 为 块作用域， 不可重复定义 

const 定义一个常量，一旦被定义后无法被重新定义， 如果为对象时，指定义的地址无法被修改，但是对象的属性可被重新定义



**var 的情况中**

for循环和内部函数的执行作用域不是同一个，内部 只是定义了一个函数

当执行内部函数时为，外部循环语句已经结束，i 为10



**let的情况下**

for循环次数个块，每次都会创建新的变量， 相当于每个函数都有自己i的副本

 let为块作用域，只对当前函数有用，定义的变量无上升到全局变量， 不会污染全局变量 

 

默认情况下 使用 const, 知道变量会被修改时使用let





# 5.31 

## 模板字符串

![image-20230531141434949](js高级.assets/image-20230531141434949.png)



## 函数默认值、剩余参数

arguments  获取所有实参的方法

伪数组和真数组的区别  

argumments 返回的为一个对象， 是伪数组

不具有数组原型上的其他方法，例如`push`、`pop`



剩余参数返回的为**真数组**，有原型对象，可以使用很多的数组方法和操作



数组赋值给对象的属性时，数组会被转换为对象的值。在 JavaScript 中，对象的属性可以是基本数据类型（如字符串、数字、布尔值）、对象或函数。

数组赋值给对象属性时，实际上是将数组的引用赋值给了属性。这意味着对象属性和原始数组引用的是同一个数组，对数组的修改将在对象属性和原始数组之间共享



## 上下文对象



上下文对象指的是调用函数的主体对象。

>在 JavaScript 中，函数是对象的一种类型，因此函数也可以作为对象的属性或方法进行调用。当函数作为对象的方法调用时，该对象就成为函数的上下文对象，也可以通过 `this` 关键字在函数内部引用该对象。
>
>下面是一个示例，演示函数作为对象方法时的上下文对象：
>
>```javascript
>javascriptCopy codevar obj = {
>  name: 'John',
>  greet: function() {
>    console.log('Hello, ' + this.name);
>  }
>};
>
>obj.greet(); // 输出 "Hello, John"
>```
>
>在上述示例中，`obj` 对象包含一个属性 `name` 和一个方法 `greet`。当调用 `obj.greet()` 时，`obj` 对象成为 `greet` 函数的上下文对象，并且在函数内部可以通过 `this.name` 引用对象的属性值。
>
>需要注意的是，函数的上下文对象在函数调用时确定，并且取决于调用函数的方式。例如，使用 `obj.greet()` 调用函数时，`obj` 是上下文对象。但是，如果将函数作为独立函数调用，那么上下文对象将是全局对象（在浏览器中为 `window`）。
>
>除了使用对象的方法调用函数外，还可以使用 `call` 或 `apply` 方法显式地设置函数的上下文对象。通过使用这些方法，可以将任意对象作为函数的上下文对象进行调用。
>
>总结：上下文对象指的是调用函数的主体对象，可以通过 `this` 关键字在函数内部引用该对象。对于函数作为对象的方法调用，对象本身成为函数的上下文对象。使用 `call` 或 `apply` 方法可以显式地设置函数的上下文对象。



## math函数的调用不需要上下文对象

>
>
>对于 `Math` 对象中的函数，它们不需要通过对象进行调用，因为它们是**全局函数**，可以直接使用 `Math` 对象来调用。
>
>在 JavaScript 中，`Math` 是一个**内置对象**，它提供了许多数学相关的方法，如 `Math.max`、`Math.min`、`Math.floor` 等。这些方法是作为 `Math` 对象的静态方法存在的，不依赖于特定的实例或对象。
>
>因此，对于 `Math` 对象中的函数调用，我们可以将上下文对象设置为任意值，包括 `null`。在实际使用中，通常习惯将上下文对象设置为 `null` 或 `undefined`，因为这些值不引用任何特定的对象。
>
>下面是一个示例，演示如何使用 `Math.max` 方法，并将上下文对象设置为 `null`：

>```javascript
>javascriptCopy codevar arr = [3, 7, 2, 9, 1];
>var max = Math.max.apply(null, arr);
>
>console.log(max); // 输出 9
>```
>
>在上述示例中，我们使用 `Math.max` 方法找到数组 `arr` 中的最大值。由于 `Math.max` 是一个静态方法，我们可以直接使用 `Math` 对象来调用它。通过使用 `apply` 方法，我们将上下文对象设置为 `null`，并将数组元素作为参数传递给 `Math.max`。
>
>需要注意的是，由于 `Math.max` 不依赖于上下文对象，因此将上下文对象设置为 `null` 是一种常见的做法，但在实际运行中并不影响函数的执行或结果。



## apply的作用

>
>
>`apply` 是 JavaScript 中的一个函数方法，它的作用是在指定的上下文中调用函数，并以数组形式传递参数。
>
>`apply` 的语法是 `function.apply(thisArg, [argsArray])`，其中：
>
>- `thisArg` 是在函数执行时作为上下文对象的值。
>- `argsArray` 是一个数组或类数组对象，包含作为参数传递给函数的值。
>
>当使用 `apply` 调用函数时，它会将数组中的元素作为参数传递给函数。这意味着，如果将一个数组作为参数传递给 `apply`，它会自动遍历数组的元素，并将它们作为参数传递给被调用的函数。
>
>以下是一个示例，演示如何使用 `apply` 将数组的元素作为参数传递给函数：
>
>```
>javascriptCopy codefunction sum(a, b, c) {
>  return a + b + c;
>}
>
>var numbers = [1, 2, 3];
>var result = sum.apply(null, numbers);
>
>console.log(result); // 输出 6
>```
>
>在上述示例中，我们定义了一个函数 `sum`，它接受三个参数并返回它们的总和。然后，我们创建一个包含三个数字的数组 `numbers`。通过使用 `apply`，我们将 `numbers` 数组的元素 `[1, 2, 3]` 作为参数传递给 `sum` 函数。最终，我们得到了总和为 `6` 的结果。
>
>需要注意的是，`apply` 方法将数组的元素作为参数传递给函数，并将其展开，而不是将整个数组作为单个参数传递。这使得可以使用可变数量的参数调用函数，而不需要手动列出每个参数。
>
>总结：`apply` 方法在函数调用时的作用是，在指定的上下文中调用函数，并以数组形式传递参数。当将数组作为参数传递给 `apply` 时，它会自动遍历数组的元素，并将它们作为参数传递给被调用的函数。



### call与apply类同-传参数有区别

总结：`apply` 和 `call` 是用于在指定上下文中调用函数的方法。它们的区别在于参数的传递方式，`apply` 使用数组或类数组对象作为参数，而 `call` 使用一系列参数作为参数。这些方法允许在特定上下文中调用函数，并传递参数给函数，以便实现特定的功能。





## bind函数绑定

>`bind()` 方法用于创建一个新的函数，该函数将指定的对象作为其上下文，并在调用时将指定的参数绑定到新函数的参数列表中。

以下是一个使用 `bind()` 方法的示例：

```javascript
javascriptCopy codefunction greet(name) {
  console.log('Hello, ' + name + '!');
}

var person = {
  name: 'Alice'
};

var greetPerson = greet.bind(person, 'Bob');
greetPerson(); // 输出 "Hello, Bob!"
```

>`bind()` 方法不会立即调用原函数，而是返回一个绑定了指定上下文和参数的新函数。如果需要立即调用新函数，可以在函数名后面加上一对括号 `()`。
>
>总结：`bind()` 方法用于创建一个新函数，并将指定的对象作为其上下文，并在调用时将指定的参数绑定到新函数的参数列表中。它的主要作用是显式绑定函数的上下文和预设参数。通过 `bind()` 方法，可以创建一个绑定了特定上下文和参数的新函数，以便在稍后的调用中使用。





## document对象

>
>
>在前端开发中，`document` 是一个全局对象，表示当前网页的文档对象模型（Document Object Model，简称 DOM）。它是 JavaScript 访问和操作网页内容的主要接口。
>
>`document` 对象提供了各种属性和方法，可以用于获取、创建和修改网页的元素、样式、文本等内容。通过 `document` 对象，可以访问网页中的各种元素，例如页面的标题、段落、图像、表单等。可以使用 `document` 对象提供的方法，例如选择元素、修改元素样式、添加或删除元素等。
>
>以下是一些常见的 `document` 对象的属性和方法：
>
>- `document.getElementById(id)`：通过指定元素的 ID 获取对应的 DOM 元素。
>- `document.querySelector(selector)`：通过 CSS 选择器选择第一个匹配的元素。
>- `document.querySelectorAll(selector)`：通过 CSS 选择器选择所有匹配的元素。
>- `document.createElement(tagName)`：创建一个指定标签名的新元素。
>- `document.createTextNode(text)`：创建一个包含指定文本内容的文本节点。
>- `document.getElementById(id).innerHTML`：获取或设置指定元素的 HTML 内容。
>- `document.getElementById(id).style.property`：获取或设置指定元素的 CSS 样式属性。
>- `document.getElementById(id).addEventListener(event, handler)`：为指定元素添加事件监听器。
>
>需要注意的是，`document` 对象是浏览器提供的内置对象，用于操作当前网页的 DOM 结构。它可以在 JavaScript 代码中直接访问，无需特别引入或声明。
>
>总结：`document` 对象是代表当前网页的文档对象模型（DOM），用于访问和操作网页的元素、样式、文本等内容。它是 JavaScript 访问网页的主要接口，提供了丰富的属性和方法，用于获取、创建和修改网页的各种元素和内容。通过 `document` 对象，可以实现对网页的动态操作和交互。



## 箭头函数

>在箭头函数中，`this` 关键字的指向与普通函数不同。
>
>箭头函数没有自己的 `this` 值，而是继承自外部作用域的 `this` 值。
>
>具体来说，箭头函数内部的 `this` 指向的是定义箭头函数时所处的词法作用域的 `this` 值，而不是调用箭头函数时的执行上下文的 `this` 值。这使得箭头函数在处理上下文绑定时更加简洁和可靠。
>
>以下是一个示例，展示了箭头函数内部的 `this` 指向：
>
>```javascript
>javascriptCopy codevar obj = {
>  name: 'Alice',
>  sayHello: function() {
>    setTimeout(() => {
>      console.log('Hello, ' + this.name + '!');
>    }, 1000);
>  }
>};
>
>obj.sayHello(); // 输出 "Hello, Alice!"，而不是 "Hello, undefined!"
>```
>
>在上述示例中，`obj` 对象包含一个 `sayHello` 方法，它使用箭头函数定义了一个延迟执行的回调函数。在箭头函数内部，我们使用 `this.name` 访问了外部的 `this` 值。由于箭头函数继承了外部作用域的 `this` 值，所以 `this.name` 实际上指向了 `obj` 对象的 `name` 属性，输出了正确的结果。
>
>相比之下，如果我们在回调函数中使用普通函数定义，`this` 的指向将发生变化：
>
>```javascript
>javascriptCopy codevar obj = {
>  name: 'Alice',
>  sayHello: function() {
>    setTimeout(function() {
>      console.log('Hello, ' + this.name + '!');
>    }, 1000);
>  }
>};
>
>obj.sayHello(); // 输出 "Hello, undefined!"
>```
>
>在这个示例中，回调函数使用**普通函数定义**，它会在调用时创建一个新的执行上下文。在这个新的执行上下文中，`this` 不再指向 `obj` 对象，而是指向全局对象（例如浏览器中的 `window` 对象）。因此，`this.name` 将返回 `undefined`。
>
>总结：箭头函数内部的 `this` 指向的是定义箭头函数时所处的词法作用域的 `this` 值，而不是调用箭头函数时的执行上下文的 `this` 值。这使得箭头函数可以更方便地访问外部作用域的 `this` 值，避免了普通函数中 `this` 指向的问题。





## 箭头函数无法实例化对象

>
>
>是的，你是正确的。箭头函数不能被使用 `new` 关键字实例化对象，因为箭头函数没有自己的 `this` 值。箭头函数的 `this` 值是继承自外部作用域，无法通过 `new` 关键字改变。
>
>当我们使用 `new` 关键字实例化一个对象时，通常会创建一个新的空对象，并将该对象作为 `this` 值传递给构造函数，以便在构造函数中初始化该对象的属性和方法。然而，箭头函数没有自己的 `this` 值，它会继承外部作用域中的 `this` 值，因此无法作为构造函数来使用。
>
>以下是一个示例，展示了箭头函数无法使用 `new` 关键字实例化对象：
>
>```javascript
>const MyConstructor = () => {
>  this.name = 'Alice'; // 错误：箭头函数没有自己的 this 值
>};
>
>const obj = new MyConstructor(); // 错误：无法使用 new 关键字实例化箭头函数
>```
>
>在上述示例中，我们尝试使用箭头函数 `MyConstructor` 作为构造函数，并使用 `new` 关键字实例化一个对象。然而，这会导致错误，因为箭头函数没有自己的 `this` 值，无法使用 `new` 关键字进行实例化。
>
>因此，在需要使用 `new` 关键字实例化对象的情况下，应该使用普通函数来定义构造函数，而不是箭头函数。普通函数具有自己的 `this` 值，并且可以通过 `new` 关键字正确地初始化对象。



#  6.2 凌晨12点45

## Smbol

Symbol定义的类型为独一无二的值， 用来定义对象的私有变量，不可被其它对象定义或改值

![image-20230602004542390](js高级.assets/image-20230602004542390.png)

使用时需要加上[ ] ， 如图， 该属性在外界访问为隐形属性

需用使用两个方法进行访问：

-  Object.getownPropertySymbols(obj), 返回obj特有的属性
-  Reflect.ownKeys(obj)



## set和weakSet

Set适用于需要存储任何类型的值，需要迭代器支持，并且不需要动态添加或删除元素的场景。而WeakSet适用于需要存储对象类型的值，需要动态添加或删除元素，并且不需要迭代器支持的场景



>
>
>Set 和 WeakSet 都是 JavaScript 中的集合类型，用于存储唯一的值。它们的主要区别在于对值的引用和存储方式的不同。
>
>Set：
>- Set 是一个可迭代的对象，它存储唯一的值，并按照插入顺序维护这些值。
>- Set 中的值可以是任何类型，包括原始类型和对象引用。
>- Set 中的值是唯一的，重复的值只会被存储一次。
>- Set 提供了一系列的方法来操作和遍历集合，如 `add()`、`delete()`、`has()` 和 `forEach()`。
>
>以下是一个使用 Set 的示例：
>
>```javascript
>const set = new Set();
>set.add(1);
>set.add(2);
>set.add(3);
>set.add(2); // 重复的值，不会被存储
>
>console.log(set.size); // 输出 3
>
>console.log(set.has(2)); // 输出 true
>
>set.forEach(value => {
>  console.log(value);
>});
>```
>
>WeakSet：
>- WeakSet 是一种特殊的集合类型，它只能存储对象引用。
>- WeakSet 中的对象引用是弱引用，不会阻止被引用对象的垃圾回收。
>- WeakSet 中的对象是唯一的，重复的对象引用不会被存储。
>- WeakSet 不可迭代，没有提供类似 `forEach()` 的遍历方法。
>
>以下是一个使用 WeakSet 的示例：
>
>```javascript
>const weakSet = new WeakSet();
>const obj1 = {};
>const obj2 = {};
>const obj3 = {};
>
>weakSet.add(obj1);
>weakSet.add(obj2);
>weakSet.add(obj3);
>weakSet.add(obj2); // 重复的对象引用，不会被存储
>
>console.log(weakSet.has(obj2)); // 输出 true
>
>weakSet.delete(obj1);
>
>console.log(weakSet.has(obj1)); // 输出 false
>```
>
>需要注意的是，WeakSet 中的对象引用是弱引用，意味着如果没有其他地方引用该对象，它可能会被垃圾回收。因此，WeakSet 通常用于存储临时的、瞬时的对象引用，例如在特定上下文中临时跟踪对象，而不会阻止这些对象被垃圾回收。
>
>



## `Object.getOwnPropertySymbols()` 方法和 `Reflect.ownKeys()` 方法

>
>
>`Object.getOwnPropertySymbols()` 方法和 `Reflect.ownKeys()` 方法都是用于获取对象的属性信息，包括符号属性（Symbol）。
>
>1. `Object.getOwnPropertySymbols()` 方法：
>   - `Object.getOwnPropertySymbols()` 方法返回一个数组，包含了指定对象自身的所有符号属性（Symbol）的属性键。
>   - 这个方法只返回对象自身的符号属性，不包括继承的属性。
>   - 使用示例：
>     ```javascript
>     const obj = {
>       [Symbol("foo")]: "fooValue",
>       [Symbol("bar")]: "barValue",
>     };
>             
>     const symbols = Object.getOwnPropertySymbols(obj);
>     console.log(symbols); // [Symbol(foo), Symbol(bar)]
>     ```
>
>2. `Reflect.ownKeys()` 方法：
>   - `Reflect.ownKeys()` 方法返回一个由目标对象自身的属性键组成的数组，包括字符串属性和符号属性（Symbol）。
>   - 这个方法返回的是目标对象自身的所有属性键，不区分属性的类型。
>   - 使用示例：
>     ```javascript
>     const obj = {
>       [Symbol("foo")]: "fooValue",
>       [Symbol("bar")]: "barValue",
>       strProp: "stringValue",
>     };
>             
>     const keys = Reflect.ownKeys(obj);
>     console.log(keys); // [Symbol(foo), Symbol(bar), 'strProp']
>     ```
>
>总结：
>- `Object.getOwnPropertySymbols()` 方法返回对象自身的所有符号属性（Symbol）的属性键的数组。
>- `Reflect.ownKeys()` 方法返回对象自身的所有属性键的数组，包括字符串属性和符号属性（Symbol）。
>
>需要注意的是，这两个方法都不会返回继承的属性，只返回对象自身的属性。如果需要获取继承的属性，可以使用 `for...in` 循环或 `Object.keys()` 方法。





## for each(val, kye)

>
>
>代码片段展示了对 Set 数据结构中的元素进行遍历并输出值和键的过程。`Set.forEach()` 方法用于遍历 Set 中的每个元素，并为每个元素执行回调函数。
>
>在你提供的代码中，`set` 是一个 Set 对象，然后使用 `set.forEach()` 方法进行遍历。回调函数接受两个参数 `val` 和 `key`，分别表示当前元素的值和键。在回调函数内部，通过 `console.log()` 分别输出 `val` 和 `key`。
>
>以下是代码的解析和示例：
>
>```javascript
>set.forEach((val, key) => {
>  console.log(val); // 输出当前元素的值
>  console.log(key); // 输出当前元素的键
>});
>```
>
>在这个示例中，假设 `set` 是一个 Set 对象，包含多个元素。通过调用 `set.forEach()` 方法，遍历每个元素并执行回调函数。在回调函数内部，`val` 表示当前元素的值，`key` 表示当前元素的键（在 Set 中，值和键相等）。
>
>请注意，Set 对象是一种集合，它不像数组那样具有索引，因此遍历元素时没有确定的顺序。在使用 `set.forEach()` 方法时，元素的顺序是根据 Set 内部的实现决定的，并不能保证顺序一致。如果需要有序的遍历，可以将 Set 转换为数组，然后使用数组的遍历方法，例如 `Array.from(set).forEach()` 或 `Array.from(set).forEach()`。



## set.size

>
>
>Set 的 `size` 属性是 Set 对象的一个只读属性，用于返回 Set 中存储的唯一值的数量。
>
>以下是关于 Set 的 `size` 属性的一些特点：
>
>- `size` 属性返回的是一个数字，表示 Set 中的唯一值的数量。
>- 当往 Set 中添加新的唯一值时，`size` 属性会自动更新。
>- `size` 属性是只读的，无法通过赋值来修改。
>
>以下是一个使用 Set 的 `size` 属性的示例：
>
>```javascript
>const set = new Set();
>
>set.add(1);
>set.add(2);
>set.add(3);
>
>console.log(set.size); // 输出 3
>
>set.add(4);
>
>console.log(set.size); // 输出 4
>
>set.delete(2);
>
>console.log(set.size); // 输出 3
>```
>
>在上述示例中，我们首先创建一个空的 Set 对象 `set`。然后，使用 `add()` 方法向 Set 中添加了一些唯一的值。通过访问 `set.size` 属性，我们可以获取 Set 中存储的唯一值的数量。在添加或删除元素后，`size` 属性会相应地更新。
>
>需要注意的是，Set 中存储的是唯一的值，重复的值只会被存储一次。因此，Set 的 `size` 属性返回的是去重后的值的数量。



## 强引用和弱引用，资源回收

>
>
>在你的示例中，虽然将 `obj` 设置为 `null`，但是由于 `set2` 中仍然保持对 `obj` 的引用，因此 `obj` 不会被垃圾回收。
>
>在 JavaScript 中，垃圾回收器通过检查对象是否存在引用来确定是否将其回收。即使你在代码中将一个对象设置为 `null`，只要其他地方仍然有对该对象的引用，它就不会被回收。
>
>在你的代码中，当执行 `set2.add(obj)` 将 `obj` 添加到 `set2` 中时，`set2` 会保持对 `obj` 的引用。即使在后续将 `obj` 设置为 `null`，`set2` 仍然保留了对原始对象的引用。
>
>因此，当你打印 `set2` 时，它仍然会显示集合中包含了原始的对象。`set2.size` 属性也会返回集合中的元素数量，因为 `obj` 仍然存在于集合中。
>
>如果你想要释放对象并从集合中删除它，可以使用 `set2.delete(obj)` 方法手动删除它，或者等待垃圾回收器自动回收无引用的对象。



## set中添加字符串数字和数字行为等价

在 Set 中，每个元素都是按照其严格相等性进行存储和比较的。当你向 Set 添加 `'1'` 时，它会被视为字符串类型的值，而不是字符

>
>
>在 Set 中，当你向 Set 添加元素时，它会根据元素的值的严格相等性进行判断，而不会根据类型进行区分。因此，添加 `1` 和 `'1'` 到 Set 中会被视为相同的元素。
>
>示例代码：
>
>```javascript
>const set = new Set();
>set.add(1);
>set.add('1');
>
>console.log(set.size); // 输出结果为 1，因为只有一个元素
>
>console.log(set.has(1)); // 输出结果为 true，元素 1 存在于 Set 中
>console.log(set.has('1')); // 输出结果为 true，元素 '1' 存在于 Set 中
>```
>
>在上述示例中，向 Set 中添加 `1` 和 `'1'`，它们的值都是相同的，都是数字1。因此，它们会被视为相同的元素，并且 Set 中只会保留一个唯一的元素。
>
>需要注意的是，尽管它们的类型不同（一个是数字，一个是字符串），但在 Set 中的严格相等性比较中，它们会被视为相等的元素。
>
>所以，添加 `1` 和 `'1'` 到 Set 中都会被识别为相同的元素，并且 Set 中只会保留一个唯一的元素。



### set集中的entries

>
>
>如果你向 Set 集合中添加了一个对象，并且在控制台中打印集合时看到了两个 `[[Entries]]`，可能是由于控制台的输出格式导致的误解。
>
>在控制台中，`[[Entries]]` 并不表示实际的元素，而是表示 Set 集合的迭代器对象。`[[Entries]]` 是迭代器对象的内部属性，用于支持集合的迭代操作。
>
>当你在控制台中打印 Set 集合时，控制台可能会以不同的方式显示集合的属性和值，具体取决于控制台的实现。有些控制台可能会显示 `[[Entries]]` 或类似的标识符，以指示该对象具有迭代器功能。
>
>下面是一个示例：
>
>```javascript
>const set = new Set();
>set.add({ name: "John" });
>
>console.log(set);
>```
>
>在某些控制台中，上述示例可能会显示类似以下的结果：
>
>```
>Set(1) { { name: "John" } }
>  [[Entries]]: Array(1)
>    0: Object
>      name: "John"
>      [[Prototype]]: Object
>```
>
>在这个输出中，`[[Entries]]` 只是迭代器对象的内部属性，并不表示实际的元素。实际的元素是在 `[[Entries]]` 数组中的索引位置上，以对象的形式存在。
>
>请注意，具体的控制台输出可能因不同的环境和控制台实现而有所不同。不同的控制台可能使用不同的方式来显示 Set 集合及其属性。
>
>总结起来，**`[[Entries]]` 只是迭代器对象的内部属性，并不表示实际的元素**。你添加的对象只有一个，所以实际元素的数量是正确的。输出中显示的 `[[Entries]]` 不会影响实际的 Set 集合元素数量。



## textContent 和 innerHtml的异同

`textContent` 和 `innerHTML` 在功能上有相似之处，都用于获取和设置元素的内容。然而，它们之间存在一些重要的区别。

1. 内容类型：
   - `textContent` 返回元素及其子节点的纯文本内容，不包括任何 HTML 标签。它只返回文本内容，并忽略任何 HTML 结构。
   - `innerHTML` 返回元素及其子节点的完整 HTML 内容，包括所有的 HTML 标签和文本内容。它返回的是一个字符串，包含元素的 HTML 结构。

2. HTML 解析和处理：
   - `textContent` 不会解析和处理 HTML，它将所有内容都视为纯文本。即使文本中包含 HTML 标签，它们也会被当作普通文本显示。
   - `innerHTML` 会解析和处理 HTML，它将传递给它的字符串作为 HTML 解析，并在元素中生成相应的 DOM 结构。它可以用于插入 HTML 片段、创建新的元素等。

3. 安全性：
   - `textContent` 是安全的，因为它不会执行任何脚本或解析任何 HTML。它只返回纯文本内容，不涉及脚本执行的风险。
   - `innerHTML` 的使用需要谨慎，因为它可以执行传递给它的 HTML 代码，包括其中的脚本。如果直接将用户提供的内容赋值给 `innerHTML`，可能会导致跨站脚本攻击（XSS）的风险。

综上所述，虽然 `textContent` 和 `innerHTML` 在功能上类似，都用于处理元素的内容，但它们的处理方式和返回的内容类型不同。你应根据需要选择适合的属性来操作元素的内容，并注意在使用 `innerHTML` 时避免安全风险。



### [].slice.call(arguments) 语句解析



语句解析：

>
>
>`[].slice.call(arguments)` 是一种常用的将类数组对象转换为真正数组的方法，它使用了 `Array` 原型上的 `slice` 方法。
>
>解析该语句的步骤如下：
>
>1. `[]` 创建了一个空数组字面量。这是因为 `slice` 方法是 `Array` 原型上的方法，我们需要通过一个数组来访问它。
>2. `slice` 是 `Array` 原型上的方法，它用于提取数组的一部分，返回一个新的数组。但是，我们这里并没有一个真正的数组，而是一个类数组对象 `arguments`。
>3. `call()` 是 `Function` 原型上的方法，它允许我们将一个函数作为指定的上下文对象进行调用。在这里，我们通过 `call()` 方法将 `slice` 方法的上下文设置为 `arguments`，以便在类数组对象上调用它。
>4. `arguments` 是一个特殊的对象，它包含了函数调用时传递的所有参数。在函数内部，我们可以使用 `arguments` 访问这些参数。但是，`arguments` 并不是一个真正的数组，它没有 `slice` 方法。通过使用 `call()` 方法，我们可以将 `slice` 方法借用到 `arguments` 对象上，使其可以像数组一样使用。
>5. 最终，`[].slice.call(arguments)` 将 `slice` 方法应用于 `arguments` 对象，并返回一个真正的数组，其中包含了 `arguments` 对象的元素。
>
>总结来说，`[].slice.call(arguments)` 的目的是将 `arguments` 对象转换为一个真正的数组。它使用了 `slice` 方法并设置了 `arguments` 作为上下文，以便在类数组对象上调用该方法。这样，我们就可以使用数组的方式来操作 `arguments` 中的参数。



slice为数组的方法， 指生成一个新的数组，通过调用Array方法，slice指定arguments（类数组的元素）， 相当于类数组对象借用数组对象方法 slice， 生成了一个数组



---



## from 和 of 方法

from 将类数组转化为数组

 of为接受任意参数(数组，数组，对象…)，并这些参数作为新数组的元素生成一个数组

>
>
>`Array.from()` 和 `Array.of()` 是 JavaScript 中用于处理数组的方法。
>
>1. `Array.from()` 方法将类数组对象或可迭代对象转换为一个新的真正的数组。它接受一个类数组对象或可迭代对象作为第一个参数，并可选地接受一个映射函数和一个上下文对象作为参数。它会返回一个新的数组，其中包含从输入对象中提取的元素。
>
>示例代码：
>```javascript
>const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
>const newArray = Array.from(arrayLike);
>console.log(newArray); // 输出结果为 ['a', 'b', 'c']
>```
>
>在上述示例中，我们将一个类数组对象 `arrayLike` 传递给 `Array.from()` 方法，它会将该对象转换为一个新的数组 `newArray`。转换结果是一个包含类数组对象的元素的真正的数组。
>
>2. `Array.of()` 方法创建一个新的数组，并将传递给它的参数作为数组的元素。它会接受任意数量的参数，并将它们作为数组的元素组合在一起。
>
>示例代码：
>```javascript
>const newArray = Array.of('a', 'b', 'c');
>console.log(newArray); // 输出结果为 ['a', 'b', 'c']
>```
>
>在上述示例中，我们将三个字符串作为参数传递给 `Array.of()` 方法，它会将这些字符串组合成一个新的数组 `newArray`。
>
>关于 `[].slice.call(arguments)` 的解释：
>
>这是一个经典的 ES5 转换类数组对象为真正数组的方法。`arguments` 对象是一个类数组对象，它包含了函数调用时传递的所有参数。由于 `arguments` 不是一个真正的数组，我们无法直接使用数组方法。通过使用 `Array.prototype.slice.call(arguments)`，我们可以借用 `Array` 原型上的 `slice()` 方法，并将 `arguments` 视为 `this` 对象进行调用。这将返回一个真正的数组，其中包含了 `arguments` 的元素。
>
>示例代码：
>```javascript
>function example() {
>  const arr = [].slice.call(arguments);
>  console.log(arr);
>}
>
>example('a', 'b', 'c'); // 输出结果为 ['a', 'b', 'c']
>```
>
>在上述示例中，我们使用 `[].slice.call(arguments)` 将 `arguments` 对象转换为一个真正的数组，并将其赋值给变量 `arr`。然后，我们打印输出了这个数组，结果为 `['a', 'b', 'c']`。这种方法允许我们在类数组对象上使用数组方法。



## 数组方法见 39 -40文件



## yield 与生成器搭配使用

>
>
>`yield` 是 JavaScript 中的一个关键字，用于定义生成器函数（Generator Function）中的一个暂停点。生成器函数是一种特殊的函数，可以通过多次迭代的方式产生一系列的值。
>
>当生成器函数执行到 `yield` 语句时，函数的执行会暂停，并将 `yield` 后面的值作为生成器的下一个值返回。生成器函数可以被多次调用，并且每次调用都会从上一个暂停点继续执行，产生下一个值。
>
>下面是一个简单的示例来说明 `yield` 的用法：
>
>```javascript
>function* generateNumbers() {
>  yield 1;
>  yield 2;
>  yield 3;
>}
>
>const generator = generateNumbers();
>
>console.log(generator.next().value); // 输出结果为 1
>console.log(generator.next().value); // 输出结果为 2
>console.log(generator.next().value); // 输出结果为 3
>console.log(generator.next().value); // 输出结果为 undefined
>```
>
>在上面的示例中，我们定义了一个生成器函数 `generateNumbers()`，它通过 `yield` 语句依次产生了数值 1、2 和 3。我们通过调用 `generateNumbers()` 返回一个生成器对象 `generator`，然后使用 `generator.next()` 来逐个获取生成器产生的值。
>
>每次调用 `generator.next()`，生成器函数会执行到下一个 `yield` 语句，并将 `yield` 后面的值作为结果返回。当生成器函数执行完所有的 `yield` 语句后，再次调用 `generator.next()` 会返回一个 `undefined` 值，表示生成器函数的执行已经结束。
>
>通过使用 `yield` 和生成器函数，我们可以实现一种更灵活和可控的迭代器，可以逐步产生值，而不是一次性返回所有的值。这在处理大型数据集或需要逐步处理的场景中非常有用。



### yield  传参

![image-20230602145356872](js高级.assets/image-20230602145356872.png)

**传入的实参作为上一个yield的返回值**

-  此举会导致第一次传入实参与yield相关的计算操作无效,不会对一个进行赋值

next的传参每次**只传给上一个yield值**，所以第一个next如果传参 则x不会被赋值 

因为yield 在yield = '2' 时中止, 所以当继续执行时,才能将赋值返回 x

第二次的传入参数 20是给了上一个yield，所以x等于20



## object.keys作用

>
>
>`Object.keys()` 是 JavaScript 中的一个静态方法，用于返回一个给定对象自身可枚举属性的数组。
>
>它接受一个对象作为参数，并返回该对象自身可枚举属性的键名（属性名）组成的数组。返回的数组中的键名按照对象中出现的顺序排列。
>
>下面是一个简单的示例来说明 `Object.keys()` 的用法：
>
>```javascript
>const obj = {
>  name: 'John',
>  age: 30,
>  city: 'New York'
>};
>
>const keys = Object.keys(obj);
>
>console.log(keys); // 输出结果为 ['name', 'age', 'city']
>```
>
>在上面的示例中，我们有一个名为 `obj` 的对象，它包含了三个属性：`name`、`age` 和 `city`。我们调用 `Object.keys(obj)` 来获取 `obj` 对象的属性名组成的数组。最后，我们将该数组打印到控制台，得到 `['name', 'age', 'city']`。
>
>需要注意的是，`Object.keys()` 只返回对象自身的可枚举属性，不包括继承的属性。如果需要获取所有的键名，包括继承的属性，可以使用 `for...in` 循环或 `Object.getOwnPropertyNames()` 方法。
>
>总结来说，`Object.keys()` 方法用于返回一个对象自身可枚举属性的键名组成的数组。它在处理对象属性时非常有用，可以帮助我们快速获取对象的属性列表。



# 6.3

## ajax

>
>
>AJAX（Asynchronous JavaScript and XML）是一种用于创建异步请求的前端技术。它通过使用 JavaScript 和浏览器提供的 XMLHttpRequest 对象，实现了在不刷新整个页面的情况下，向服务器发送请求并获取响应数据的能力。
>
>传统的网页交互通常需要整页刷新，而使用 AJAX 技术可以在后台与服务器进行数据交换，只更新页面的部分内容，从而提升用户体验和页面性能。
>
>AJAX 的特点包括：
>
>1. 异步通信：AJAX 使用异步方式发送请求和处理响应，不会阻塞页面的其他操作。
>
>2. 部分刷新：通过 AJAX，可以仅更新页面的部分内容，而不需要刷新整个页面。
>
>3. 数据交换：AJAX 可以与服务器进行数据交换，包括发送数据到服务器和获取服务器返回的数据。
>
>4. 前端技术：AJAX 是一种前端技术，利用 JavaScript 和 XMLHttpRequest 对象实现异步通信。
>
>5. 数据格式：尽管名字中包含 "XML"，但实际上 AJAX 并不限于 XML 格式，可以处理各种数据格式，如 JSON、HTML、文本等。
>
>AJAX 技术被广泛应用于现代 Web 开发中，用于实现动态网页、无刷新表单提交、实时数据更新等功能。它提供了更好的用户体验和页面性能，并使得前端与后端之间的数据交互更加灵活和高效。AJAX（Asynchronous JavaScript and XML）是一种用于创建异步请求的前端技术。它通过使用 JavaScript 和浏览器提供的 XMLHttpRequest 对象，实现了在不刷新整个页面的情况下，向服务器发送请求并获取响应数据的能力。
>
>传统的网页交互通常需要整页刷新，而使用 AJAX 技术可以在后台与服务器进行数据交换，只更新页面的部分内容，从而提升用户体验和页面性能。
>
>AJAX 的特点包括：
>
>1. 异步通信：AJAX 使用异步方式发送请求和处理响应，不会阻塞页面的其他操作。
>
>2. 部分刷新：通过 AJAX，可以仅更新页面的部分内容，而不需要刷新整个页面。
>
>3. 数据交换：AJAX 可以与服务器进行数据交换，包括发送数据到服务器和获取服务器返回的数据。
>
>4. 前端技术：AJAX 是一种前端技术，利用 JavaScript 和 XMLHttpRequest 对象实现异步通信。
>
>5. 数据格式：尽管名字中包含 "XML"，但实际上 AJAX 并不限于 XML 格式，可以处理各种数据格式，如 JSON、HTML、文本等。
>
>AJAX 技术被广泛应用于现代 Web 开发中，用于实现动态网页、无刷新表单提交、实时数据更新等功能。它提供了更好的用户体验和页面性能，并使得前端与后端之间的数据交互更加灵活和高效。



## 同步信息和异步信息

>
>
>同步信息和异步信息是指在计算机通信或数据传输中，消息的传递方式和处理方式的不同。
>
>- 同步信息：在同步通信中，发送方发送消息后会等待接收方对消息的处理和回复，发送方会一直阻塞等待直到接收到回复或超时。在同步模式下，通信双方的操作是相互依赖的，必须按照确定的顺序和时间进行消息的传递和处理。
>
>- 异步信息：在异步通信中，发送方发送消息后不会立即等待接收方的回复，而是可以继续进行其他操作。发送方和接收方是相互独立的，可以并行进行消息的发送和处理。接收方可以在合适的时间处理消息，并在处理完毕后发送回复。异步通信可以提高系统的并发性和响应性，允许同时处理多个消息和任务。
>
>在计算机网络和Web开发中，常用的异步通信方式包括 AJAX、WebSocket、异步请求等，这些技术可以在不阻塞用户界面的情况下进行数据传输和处理。相比之下，同步通信方式会造成阻塞，因为发送方必须等待接收方的回复才能继续进行后续操作。
>
>总的来说，同步信息和异步信息是根据消息的传递方式和处理方式来区分的，它们在不同的场景和需求下有不同的应用和优势。



### 适用场景

同步信息和异步信息是指在计算机通信或数据传输中，消息的传递方式和处理方式的不同。

- **同步信息**：在同步通信中，发送方发送消息后会等待接收方对消息的处理和回复，发送方会一直阻塞等待直到接收到回复或超时。**在同步模式下**，**通信双方的操作是相互依赖的，必须按照确定的顺序和时间进行消息的传递和处理。**
- **异步信息**：在**异步通信**中，发送方发送消息后不会立即等待接收方的回复，而是可以继续进行其他操作。发送方和接收方是**相互独立**的，可以并行进行消息的发送和处理。接收方可以在合适的时间处理消息，并在处理完毕后发送回复。异**步通信可以提高系统的并发性和响应性，允许同时处理多个消息和任务。**

在计算机网络和Web开发中，常用的异步通信方式包括 AJAX、WebSocket、异步请求等，这些技术可以在不阻塞用户界面的情况下进行数据传输和处理。相比之下，同步通信方式会造成阻塞，因为发送方必须等待接收方的回复才能继续进行后续操作。

总的来说，同步信息和异步信息是根据消息的传递方式和处理方式来区分的，它们在不同的场景和需求下有不同的应用和优势。



同步信息： 可以确保信息的准确性，可靠性和一致性，当需要按照特定的顺序处理时，使用此处理方式

异步信息：避免阻塞，并发性，发送方和接送方相互独立，可以并行发送信息和处理，可提高系统的并发性和适用性，允许同时处理多个消息和任务。



## jquery库

>
>
>jQuery是一个广泛使用的JavaScript库，它简化了JavaScript与HTML文档、处理事件、执行动画、处理AJAX请求等常见操作之间的交互。jQuery的目标是使Web开发更加简单、快速和可靠。
>
>以下是一些jQuery的特点和功能：
>
>1. 简化DOM操作：jQuery提供了简洁而强大的DOM操作方法，使开发者可以轻松地选择元素、修改样式、操作内容、处理事件等，不需要编写冗长的原生JavaScript代码。
>
>2. 事件处理：jQuery简化了事件处理的过程，通过统一的事件绑定和处理方法，开发者可以方便地为元素添加事件监听器，响应用户的交互操作。
>
>3. 动画效果：jQuery提供了丰富的动画效果和过渡效果的方法，使开发者能够轻松地创建各种动态效果，如淡入淡出、滑动、渐变等，提升用户体验。
>
>4. AJAX请求：jQuery简化了使用AJAX进行数据交互的过程，提供了简单易用的AJAX方法，使开发者可以轻松地发送异步请求、处理响应、更新页面内容。
>
>5. 跨浏览器兼容性：jQuery封装了许多常见的跨浏览器兼容性问题，使开发者可以更好地处理不同浏览器之间的差异，确保代码在各种环境下的稳定性和一致性。
>
>总的来说，jQuery简化了JavaScript在Web开发中的许多常见任务，使开发者能够更高效地编写代码，并提供了丰富的插件生态系统，使开发者能够通过扩展功能来满足各种需求。它在过去的几年中广泛应用于Web开发，但随着现代Web技术的发展，如ES6和前端框架的兴起，jQuery的使用逐渐减少，但仍然在一些项目和旧有代码中被广泛使用。



## Jquery的使用

>
>
>使用jQuery非常简单，以下是一些基本的使用方式：
>
>1. 引入jQuery库：在HTML文件的`<head>`或`<body>`标签中添加如下代码，引入jQuery库文件。
>```html
><script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
>```
>
>2. 编写jQuery代码：在引入jQuery库后，就可以在JavaScript代码中使用jQuery的功能了。
>
>   - 选择元素：可以使用CSS选择器来选择DOM元素。
>   ```javascript
>   // 选择所有的段落元素并隐藏它们
>   $("p").hide();
>   ```
>
>   - 修改元素样式：可以使用`css()`方法来修改元素的CSS样式。
>   ```javascript
>   // 将所有标题元素的颜色设置为红色
>   $("h1, h2, h3").css("color", "red");
>   ```
>
>   - 处理事件：可以使用`on()`方法来绑定和处理事件。
>   ```javascript
>   // 当按钮被点击时显示一个提示框
>   $("#myButton").on("click", function() {
>     alert("Button clicked!");
>   });
>   ```
>
>   - 发送AJAX请求：可以使用`$.ajax()`方法发送异步请求。
>   ```javascript
>   // 发送GET请求并处理响应
>   $.ajax({
>     url: "https://api.example.com/data",
>     method: "GET",
>     success: function(response) {
>       console.log(response);
>     },
>     error: function(error) {
>       console.error(error);
>     }
>   });
>   ```
>
>3. 在文档加载完成后执行jQuery代码：为了确保jQuery代码在DOM加载完成后执行，可以将代码放在`$(document).ready()`函数中，或者使用简化的`$(function() { ... })`形式。
>```javascript
>$(document).ready(function() {
>  // 在DOM加载完成后执行的代码
>});
>
>// 或者简化形式
>$(function() {
>  // 在DOM加载完成后执行的代码
>});
>```
>
>以上是一个简单的jQuery使用示例，你可以根据自己的需求使用jQuery提供的各种功能。如果需要更多详细的信息和示例，可以参考jQuery官方文档：[https://jquery.com/](https://jquery.com/)





### 异步代码同步化 和 递归类似

>
>
>生成器和递归确实有一些相似之处，尤其是在处理异步操作时。
>
>递归是一种通过函数调用自身的方式来解决问题的编程技巧。递归函数可以在每次调用时处理一部分任务，并通过递归调用自身来继续处理剩余的任务，直到达到终止条件。这种方式可以使代码具有循环的效果，但实际上是通过函数调用栈来实现的。
>
>生成器函数是ES6中引入的一种特殊函数，它可以通过`yield`关键字暂停函数的执行，并可以在需要时继续执行。生成器函数通常与迭代器一起使用，可以按需产生值序列。生成器函数可以通过`yield`表达式来生成值，并且可以通过`next()`方法来恢复函数的执行。在处理异步操作时，生成器函数可以暂停等待异步操作完成，然后继续执行后续的代码。
>
>生成器函数的异步代码同步化的感觉与递归类似，因为它们都能够通过暂停和继续执行的方式来处理复杂的任务。不同之处在于生成器函数是通过`yield`和`next()`来控制执行流程，而递归则是通过函数调用自身来实现。
>
>总的来说，生成器函数和递归都是处理复杂任务的有效工具，在不同的场景下可以选择适合的方法来解决问题。生成器函数在处理异步操作时提供了更直观、简洁的代码结构，可以帮助处理异步代码的可读性和可维护性。





# 6.4



## 回调地狱

>
>
>回调地狱是指在处理多个异步操作时，由于回调函数的嵌套使用，导致代码结构复杂、难以维护和理解的情况。
>
>在传统的异步编程中，如果有多个异步操作需要按照一定的顺序执行或者有依赖关系，通常会使用回调函数来处理异步操作的结果。但是当异步操作嵌套多层时，每个异步操作的结果都需要在回调函数中处理，这就导致了回调函数的嵌套，代码的缩进层级不断增加，形成了回调地狱。
>
>回调地狱的问题包括：
>
>1. 代码结构复杂，可读性差：由于回调函数的嵌套，代码结构变得难以理解和维护，尤其是当异步操作较多时。
>
>2. 错误处理困难：在回调地狱中，错误处理变得复杂，很难追踪和处理每个异步操作可能出现的错误。
>
>3. 可扩展性差：如果需要添加更多的异步操作或者修改异步操作的顺序，需要不断修改回调函数的嵌套结构，代码变得脆弱且难以扩展。
>
>为了解决回调地狱的问题，出现了一些异步编程的解决方案，如Promise、Async/Await等，它们可以更优雅地处理异步操作，避免了回调函数的嵌套，提升了代码的可读性和可维护性。



## 生成器对回调地狱ajax的作用,及生成器本身的作用

>
>
>生成器函数（Generator）可以用于解决回调地狱问题，但并不是它的主要目的。
>
>生成器函数是一种特殊类型的函数，使用`function*`语法定义，内部使用`yield`关键字来暂停和恢复函数的执行。生成器函数可以通过迭代器的方式逐步产生值，从而实现异步代码的同步化编写。
>
>在处理异步操作时，生成器函数可以通过`yield`暂停函数的执行，等待异步操作的完成，并使用`next()`方法来继续执行后续的代码。这种方式使得**异步代码的书写更加直观和线性，避免了回调函数的嵌套和回调地狱。**
>
>通过结合生成器函数和Promise对象，可以实现更优雅的异步编程模式，常见的称为"Generator + Promise"模式或"Async Generator"模式。在这种模式下，生成器函数用于控制异步操作的流程，而Promise对象用于处理具体的异步操作。
>
>生成器函数的作用不仅仅局限于解决回调地狱问题，它还具有以下特点和作用：
>
>1. 简化异步代码的编写：生成器函数使得异步代码的编写更加直观和线性，不需要嵌套的回调函数，提高了代码的可读性和可维护性。
>
>2. 支持暂停和恢复：生成器函数可以通过`yield`暂停函数的执行，并通过`next()`方法继续执行后续的代码。这种能力可以用于实现迭代器、状态机等复杂的控制流程。
>
>3. 可以处理异步和同步操作：生成器函数既可以处理异步操作，也可以处理同步操作，灵活性较高。
>
>虽然生成器函数可以用于简化异步代码的编写，但它并不是解决回调地狱问题的唯一方案。在现代的JavaScript中，还有其他更强大的异步编程解决方案，如Promise、Async/Await等，它们能够更好地处理异步操作，提供更简洁和可读性更高的代码。生成器函数在特定的场景下仍然是一个有用的工具，但在实际开发中，可以根据需求和团队的技术栈选择适合的异步编程方案。

 

## promise对象及作用

>
>
>Promise对象是JavaScript中的一种异步编程解决方案，用于处理异步操作和生成异步代码。
>
>Promise对象代表了一个尚未完成的异步操作，可以处于三种状态之一：进行中（pending）、已完成（fulfilled）和已拒绝（rejected）。当异步操作完成或失败时，Promise对象的状态会发生相应的改变。
>
>Promise对象的作用主要有以下几个方面：
>
>1. 简化异步操作的处理：Promise对象提供了一种更优雅、可读性更高的方式来处理异步操作，避免了回调地狱的问题，使得异步代码更易于编写和维护。
>
>2. 提供了一种标准的异步编程接口：Promise对象定义了一组标准的方法（如`then()`、`catch()`、`finally()`），用于处理异步操作的状态变化、获取异步操作的结果或捕获异常。这些方法使得异步代码的编写和组合更加灵活和统一。
>
>3. 支持链式调用：Promise对象的方法可以通过链式调用的方式进行组合，使得多个异步操作可以按照特定的顺序和条件依次执行，减少了回调函数的嵌套和复杂度。
>
>4. 提供了错误处理机制：Promise对象可以通过`catch()`方法捕获和处理异步操作中的异常，避免了错误被忽略或导致程序崩溃的情况。
>
>总之，Promise对象是一种用于处理异步操作的标准化解决方案，它提供了一种更好的编程模式，使得异步代码更加可读、可维护和可组合，提高了代码的可靠性和开发效率。



## 模拟异步操作



模拟异步操作是指在代码中使用一些延时机制（例如定时器）来模拟实际的异步行为，尽管实际上它们是同步执行的。

在 JavaScript 中，通常通过使用定时器函数（如 `setTimeout` 或 `setInterval`）来创建一个延时，以模拟异步操作的完成时间。通过设置一个适当的延时时间，可以模拟网络请求、文件读取、数据库查询等实际的异步操作。

例如，在前面提到的示例中，使用了 `setTimeout` 函数来模拟一个异步操作，在延时结束后调用 `resolve` 函数表示操作成功，并传递了一个字符串作为成功的结果。

实际的异步操作可能涉及与服务器通信、文件系统读写、数据库查询等耗时的操作，而模拟异步操作只是为了演示和理解异步编程的概念，而不是真正的异步行为。



## 在promise中，resolve 和 reject负责控制对象状态

```javascript
setTimeout(function() {
  resolve("Operation successful");
}, 2000);  在这部分代码中。能否将resolve替换为return？
```

>
>
>在 Promise 的构造函数中，`resolve` 和 `reject` 是用来控制 Promise 对象状态的内部方法，它们并不是普通的 JavaScript 关键字，因此不能直接替换为 `return`。
>
>在上述代码中，`resolve("Operation successful")` 表示将 Promise 的状态从未完成（pending）改变为已解决（fulfilled），并传递 "Operation successful" 作为解决值。这是 Promise 提供的机制，用于通知 Promise 对象的使用者操作成功完成。
>
>而 `return` 关键字是用来从函数中返回值的，它将函数执行的结果返回给调用者。在 Promise 的构造函数中，我们无法通过 `return` 关键字来返回一个值给调用者，因为 Promise 的构造函数并不是一个普通的函数调用。
>
>因此，对于 Promise 的构造函数中的异步操作，我们需要使用 `resolve` 方法来改变 Promise 的状态，并将解决值传递给后续的 `.then()` 方法的回调函数。这样，我们就可以在异步操作完成后通过 `.then()` 方法来处理 Promise 的结果。





## XMLHttpRequest

XMLHttpRequest 是一种在 JavaScript 中发送 HTTP 请求的对象。它提供了一种在不刷新页面的情况下与服务器进行数据交互的方式，常用于实现 AJAX（Asynchronous JavaScript and XML）功能。

使用 XMLHttpRequest，你可以发送各种类型的请求（例如 GET、POST、PUT、DELETE）到服务器，并通过监听事件来处理服务器的响应。它可以发送异步请求，也可以发送同步请求，**但通常推荐使用异步方式以避免阻塞页面加载和用户交互。**

以下是一个简单的使用 XMLHttpRequest 发送 GET 请求的示例：

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);

xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var response = xhr.responseText;
    console.log(response);
  }
};

xhr.send();
```

在上述示例中，首先创建了一个 XMLHttpRequest 实例 `xhr`。然后，使用 `open()` 方法指定请求的类型（GET）、URL（https://api.example.com/data）和是否异步（true）。

接下来，通过设置 `onreadystatechange` 事件处理程序来监听请求状态的变化。当 `xhr.readyState` 的值为 4 且 `xhr.status` 的值为 200 时，表示请求已完成且响应状态为成功，我们可以通过 `xhr.responseText` 获取服务器返回的数据。

最后，调用 `send()` 方法发送请求。

需要注意的是，以上示例只是一个简单的 GET 请求示例，XMLHttpRequest 还提供了其他方法和属性，用于设置请求头、发送 POST 请求、上传文件等操作。详细的使用方法可以参考相关文档或教程。



## XMLHttpRequest常用内置方法

XMLHttpRequest 对象具有以下常用的内置方法：

1. `open(method, url, async)`：初始化一个请求。指定请求的方法（如 GET、POST），请求的 URL 和是否使用异步方式发送请求。

2. `send(data)`：发送请求。可选地传入请求的主体数据，如 POST 请求的表单数据。

3. `abort()`：中止当前的请求。

4. `getAllResponseHeaders()`：返回所有的响应头信息。

5. `getResponseHeader(header)`：返回指定响应头的值。

6. `setRequestHeader(header, value)`：设置请求头的值。

这些方法用于控制 XMLHttpRequest 对象的行为和与服务器进行通信。`open()` 方法用于初始化请求，`send()` 方法用于发送请求，`abort()` 方法用于中止请求。`getAllResponseHeaders()` 和 `getResponseHeader()` 方法用于获取响应头信息，`setRequestHeader()` 方法用于设置请求头信息。





## 页面采用同步请求后阻塞

当使用同步请求（`XMLHttpRequest` 的 `open` 方法的第三个参数为 `false`）时，页面会被阻塞，直到请求完成才会继续执行后续的代码。这种阻塞的表现可以体现在以下几个方面：

1. **用户无法进行其他操作**：由于代码执行被阻塞，用户无法与页面进行交互，包括点击按钮、输入表单等操作。
2. **页面加载停顿：**如果同步请求发生在页面加载过程中，页面加载会停顿，直到请求完成才会继续加载页面的其他内容。
3. **响应时间延长**：同步请求会导致页面等待服务器响应，如果服务器响应时间较长，页面会一直处于等待状态，直到响应返回才能继续执行后续的代码。

总之，同步请求会阻塞页面的交互和加载，导致用户体验下降。因此，推荐使用异步请求来避免页面的阻塞，让页面能够快速响应用户操作，并在后台进行数据的获取和处理。



## 异步请求在生活中的应用

异步请求在实际生活中的应用非常广泛，以下是一些常见的应用场景：

1. 网页加载：当用户访问网页时，网页内容通常会通过异步请求从服务器获取，以提高加载速度和用户体验。

2. 表单提交：在表单提交过程中，可以使用异步请求将表单数据发送到服务器进行处理，而不需要刷新整个页面。

3. 数据更新：在实时数据更新的场景中，例如聊天应用、股票市场等，可以使用异步请求从服务器获取最新的数据并更新页面。

4. 图片和媒体加载：当页面需要加载大量图片或媒体文件时，可以使用异步请求进行延迟加载，以提高页面的加载速度。

5. 用户交互操作：例如点击按钮触发某些操作，可以使用异步请求将操作请求发送到服务器进行处理，并在操作完成后更新页面内容。

6. API调用：与服务器进行数据交互的应用程序通常会使用异步请求调用API，以获取或提交数据。

7. 数据缓存和预取：使用异步请求可以将数据缓存在本地或预先加载数据，以提高应用程序的性能和响应速度。

这些只是一些常见的应用场景，实际上，异步请求在许多其他领域和应用中也被广泛使用，以实现更好的性能、用户体验和数据交互。



## 高阶函数

高阶函数是指能够接受一个或多个函数作为参数，并/或返回一个新函数的函数。换句话说，高阶函数将函数作为值进行操作，使得函数可以作为参数传递和返回值使用。

高阶函数的特点是：

1. 接受一个或多个函数作为参数：高阶函数可以接受其他函数作为参数，以便在函数体内对其进行操作或调用。

2. 返回一个新函数：高阶函数可以根据传入的参数函数，返回一个新的函数作为结果。

高阶函数的应用场景有很多，包括但不限于：

1. 回调函数：将一个函数作为参数传递给另一个函数，在适当的时候调用传入的函数，常见于事件处理、异步操作等。

2. 函数组合：将多个函数组合在一起，形成一个新的函数。可以通过函数的嵌套调用或使用函数组合工具库（如Lodash的`compose`函数）来实现。

3. 部分应用函数：通过传递部分参数给函数，返回一个新的函数，用于延迟执行或减少重复代码。

4. 柯里化（Currying）：将接受多个参数的函数转换为接受单个参数的函数序列，返回一个新函数。柯里化可以实现参数复用、延迟执行等功能。

通过使用高阶函数，可以提高代码的灵活性、可重用性和可扩展性，使得函数可以更加动态地组合和定制。



### 闭包（promise 涉及 定时器）

闭包是指函数能够访问并使用其词法作用域外部的变量的能力。换句话说，闭包是由函数及其相关的引用环境组合而成的包裹（closure），使得函数可以访问在其定义时不在其作用域内的变量。

闭包的特点是：

1. 函数嵌套：闭包通常涉及函数的嵌套，即一个函数在另一个函数内部定义。

2. 内部函数访问外部变量：内部函数可以访问外部函数的变量和参数，即使外部函数已经执行结束。

闭包的作用和用途有以下几个方面：

1. 保护变量：闭包可以创建一个私有的作用域，将变量封装在函数内部，避免变量被外部访问和修改。

2. 延迟执行：通过闭包可以延迟执行函数，将函数的调用推迟到特定的时机，例如在事件处理函数中。

3. 记忆和缓存：闭包可以将中间结果保存在闭包的环境中，提供记忆和缓存的功能，避免重复计算。

4. 模块化和封装：通过使用闭包可以实现模块化的编程，将相关的函数和数据封装在一个闭包中，提供对外的接口。

需要注意的是，由于闭包会保留对外部变量的引用，可能导致内存泄漏的问题。在使用闭包时，需要注意管理好变量的生命周期，避免不必要的内存占用。



### promise - then的第二个参数 和 catch处理失败状态等价

>
>
>在你提供的代码中，`(err) => { console.log(err); }` 是 `then` 方法的第二个参数，用于处理 Promise 对象的 rejected（失败）状态。这种形式的 `then` 方法可以用来指定成功和失败状态的回调函数。
>
>在这种写法中，第一个函数参数是处理 Promise 对象的 resolved（成功）状态的回调函数，第二个函数参数是处理 Promise 对象的 rejected（失败）状态的回调函数。如果 Promise 对象的状态变为 rejected，则会执行第二个函数参数中的回调函数来处理错误情况。
>
>实际上，这种写法与使用 `catch` 方法来处理失败状态是等价的。可以将上述代码重写为：
>
>```javascript
>pro.then(
>  (val) => {
>    console.log(val);
>  }
>).catch(
>  (err) => {
>    console.log(err);
>  }
>);
>```
>
>无论是使用第二个参数的 `then` 方法还是使用 `catch` 方法，都是用来处理 Promise 对象的失败状态，并提供相应的错误处理逻辑。



## promise- 链式调用

>
>链式调用是指在 Promise 中使用连续的 `then` 方法来串联多个异步操作。每个 `then` 方法都返回一个新的 Promise 对象，使得可以在每个异步操作完成后继续进行下一个操作。
>
>通过链式调用，可以按顺序执行一系列的异步操作，并在每个操作完成后处理返回的结果。这种方式可以避免回调地狱（callback hell）的问题，使代码更加清晰和易于维护。
>
>以下是一个简单的链式调用示例：
>
>```javascript
>getData()
>  .then((data) => processData(data))
>  .then((result) => displayResult(result))
>  .catch((error) => handleError(error));
>```
>
>在这个例子中，`getData` 函数返回一个 Promise 对象，我们可以在它的后面使用 `then` 方法来指定成功状态的处理逻辑。`processData` 函数也返回一个 Promise 对象，它会在前一个操作成功后被调用。`displayResult` 函数处理 `processData` 返回的结果，并继续返回一个 Promise 对象。最后，`catch` 方法用于捕获任何发生的错误。
>
>通过链式调用，我们可以将一系列的异步操作串联起来，使代码更加简洁和可读。



## axios

>
>
>Axios 是一个基于 Promise 的现代化 HTTP 客户端，用于浏览器和 Node.js 环境。它可以用于发送 HTTP 请求并处理响应，提供了简单且强大的 API。
>
>Axios 的特点和功能包括：
>
>1. 支持多种浏览器和 Node.js 环境：Axios 可以在浏览器和 Node.js 环境中使用，因此适用于前端和后端开发。
>2. 提供简洁和一致的 API：Axios 提供了一组简洁且一致的方法来发送各种类型的 HTTP 请求，包括 GET、POST、PUT、DELETE 等。
>3. 支持 Promise：Axios 使用 Promise 进行异步操作处理，可以使用 `then` 和 `catch` 方法处理成功和失败的回调。
>4. 提供请求和响应拦截器：可以在请求发送和响应接收的过程中添加拦截器，对请求和响应进行处理、修改或拦截。
>5. 自动转换数据格式：Axios 可以自动将请求和响应的数据格式进行转换，支持 JSON、XML、FormData 等多种格式。
>6. 提供取消请求的功能：Axios 允许取消正在进行的请求，防止不必要的网络流量。
>7. 支持并发请求：Axios 提供了并发请求的功能，可以同时发送多个请求并处理它们的响应。
>
>使用 Axios 可以简化 HTTP 请求的操作，并提供了许多方便的功能来处理请求和响应。它是一个流行的 HTTP 客户端库，被广泛应用于前后端开发中。
>
>



#### 拓展知识： api优缺点

>
>
>是的，API 接口提供了很大的灵活性和便利性，可以让开发者无需从头开发整个应用，而是通过调用 API 接口获取所需的数据或功能。这可以节省开发成本和时间，并快速实现功能。
>
>然而，API 接口也有一些潜在的危险性和缺点需要注意：
>
>1. 安全风险：暴露 API 接口可能会带来安全风险，例如未经授权的访问、数据泄露等。因此，在设计和使用 API 接口时，要考虑安全性并采取相应的安全措施，例如身份验证、授权机制等。
>
>2. 可靠性和稳定性：依赖外部的 API 接口意味着你的应用的可靠性和稳定性受到第三方的影响。如果 API 接口出现故障、升级或不稳定，可能会导致你的应用无法正常工作。
>
>3. 数据一致性和更新频率：使用 API 接口获取数据可能会面临数据一致性和更新频率的问题。如果 API 提供商的数据更新不及时或不一致，可能会影响你的应用的准确性和可靠性。
>
>4. 限制和费用：一些 API 接口可能会有访问限制、请求限制或收费规定。你需要了解并遵守 API 提供商的使用规则，以避免违规使用或超出限制。
>
>综上所述，使用 API 接口可以带来很多好处，但也需要注意相关的安全、稳定性和数据质量问题，并遵守 API 提供商的规定和限制。

### 使用场景

导入 API 接口在项目开发中可以起到很大的作用，特别是在需要使用外部服务或数据的情况下。以下是导入 API 接口的一些主要好处：

1. 获取外部数据：通过导入 API 接口，可以从外部服务或数据源获取实时数据，例如天气数据、地理位置信息、金融数据等。这使得项目可以获得最新的、准确的数据来支持其功能和需求。

2. 扩展功能：通过导入 API 接口，可以利用外部服务的功能来扩展项目的功能。例如，可以导入支付接口以实现在线支付功能，导入社交媒体接口以实现社交分享功能等。

3. 提高效率：导入 API 接口可以节省开发时间和资源。相对于自己开发相同功能的模块，直接使用 API 接口可以减少重复劳动，提高开发效率。

4. 保持更新和稳定性：使用 API 接口意味着项目可以依赖外部服务来处理特定的任务，而不需要自己处理这些复杂的逻辑。这样可以确保功能的稳定性和持续更新，而无需自己负责维护和更新相关代码。

总而言之，导入 API 接口是项目开发中常见且重要的操作，它可以帮助项目获得外部数据、扩展功能、提高效率并保持更新和稳定性。在选择和使用 API 接口时，需要考虑其适用性、可靠性、安全性和文档支持等因素，以确保项目的成功和可持续发展。



#### 拓展知识： vpn包装隧道

VPN（Virtual Private Network）可以给原始 IP 地址包装，提供网络流量的加密和隧道功能。当你连接到 VPN 服务器时，你的网络流量会通过 VPN 服务器进行传输，使得外界无法直接识别你的真实 IP 地址。相反，外界只能看到 VPN 服务器的 IP 地址。

通过使用 VPN，你可以隐藏你的真实 IP 地址，增加网络安全性和隐私保护。VPN 会将你的网络流量加密，并通过建立安全的隧道将流量传输到目标服务器，这样可以防止第三方监听和窃取你的数据。

此外，VPN 还可以提供访问地理限制内容的功能。例如，如果某些网站或服务在你所在的地区不可用，你可以通过连接到位于允许访问的地区的 VPN 服务器来绕过这些限制，获取访问权限。

总之，VPN 提供了一种安全的方式来保护你的网络通信，并提供了匿名性和访问限制内容的能力。



# 6.5	 10：30



#### 扩展知识 原生java

自己实现功能

>
>
>原生 JavaScript 指的是使用纯粹的 JavaScript 语言和浏览器提供的原生功能，而不依赖于任何第三方库或框架。它是 JavaScript 语言的标准实现，由浏览器厂商提供和支持。
>
>原生 JavaScript 具有以下特点：
>
>1. 标准化：原生 JavaScript 遵循 ECMAScript 标准，这是一种定义了 JavaScript 语言规范的国际标准。
>
>2. 跨平台：原生 JavaScript 可以在不同的浏览器和操作系统上运行，因为它是浏览器的内置语言。
>
>3. 原生功能：原生 JavaScript 提供了许多内置的功能和对象，如 DOM 操作、事件处理、AJAX 请求、定时器、字符串处理、数组操作等。
>
>4. 性能优化：原生 JavaScript 的执行速度通常比使用第三方库或框架更快，因为它不需要加载额外的代码和资源。
>
>5. 学习曲线：学习原生 JavaScript 可以更好地理解和掌握 JavaScript 语言的核心概念和特性，为进一步学习和使用其他框架或库打下坚实的基础。
>
>尽管有许多流行的 JavaScript 框架和库（如 jQuery、React、Vue.js 等），但原生 JavaScript 仍然是开发者进行前端开发的基础。使用原生 JavaScript 可以实现灵活、高效和可维护的代码，并具有更好的跨平台兼容性。



>
>
>原生 JavaScript 指的是在不依赖第三方库或框架的情况下，使用纯粹的 JavaScript 语言来实现所需功能的过程。这意味着您自己编写代码来处理各种任务，例如操作 DOM 元素、处理用户输入、发送网络请求、执行动画效果等。
>
>**原生 JavaScript 开发涉及以下方面：**
>
>1. 操作 DOM：使用原生 JavaScript 可以选择、修改、添加或删除 HTML 元素，并响应用户交互。
>
>2. 事件处理：使用原生 JavaScript 可以监听和处理各种事件，如点击、鼠标移动、键盘输入等。
>
>3. 数据处理：使用原生 JavaScript 可以创建和操作数据结构，如数组、对象、字符串，执行各种操作，如排序、过滤、映射等。
>
>4. 网络请求：使用原生 JavaScript 可以发送 HTTP 请求，获取数据并处理响应。
>
>5. 动画效果：使用原生 JavaScript 可以通过操作 CSS 样式和定时器来创建动画效果。
>
>6. 表单验证：使用原生 JavaScript 可以验证用户输入的表单数据，并提供反馈和错误处理。
>
>使用原生 JavaScript 开发可以让您更好地理解语言的核心概念和特性，并具有更大的灵活性和自定义能力。同时，原生 JavaScript 开发也有助于优化性能，减少依赖性，并提供更好的跨平台兼容性。
>
>当然，如果您发现在特定情况下使用现有的第三方库或框架可以更好地满足需求，您也可以选择使用它们。但了解和掌握原生 JavaScript 仍然是一个重要的基础。





## promise对象的race()方法及作用



>Promise.race() 方法用于将多个 Promise 对象包装成一个新的 Promise 对象，并返回最先解决或拒绝的 Promise 的结果或原因。
>
>该方法接受一个可迭代的参数，通常是一个包含多个 Promise 对象的数组或类似数组的对象。它会遍历这些 Promise 对象，并返回一个新的 Promise 对象，该 Promise 对象的状态和值将取决于最先解决或拒绝的 Promise 对象。
>
>具体而言，Promise.race() 方法的参数表示一组竞争的 Promise 对象。它们可以是任意数量的 Promise 对象，它们之间并不一定需要相同的类型或含义。
>
>当其中任何一个 Promise 对象解决（即状态变为 fulfilled）时，返回的 Promise 对象也会解决，并携带解决的值。如果其中任何一个 Promise 对象被拒绝（即状态变为 rejected），返回的 Promise 对象也会被拒绝，并携带拒绝的原因。
>
>换句话说，Promise.race() 方法将多个 Promise 对象竞争执行，一旦有一个 Promise 对象完成（解决或拒绝），返回的 Promise 对象就会立即采用该 Promise 对象的状态和结果。
>
>示例用法：
>```javascript
>const promise1 = new Promise((resolve, reject) => {
>  setTimeout(() => resolve('Promise 1 resolved'), 1000);
>});
>
>const promise2 = new Promise((resolve, reject) => {
>  setTimeout(() => resolve('Promise 2 resolved'), 2000);
>});
>
>const promise3 = new Promise((resolve, reject) => {
>  setTimeout(() => reject(new Error('Promise 3 rejected')), 1500);
>});
>
>Promise.race([promise1, promise2, promise3])
>  .then(result => console.log(result)) // 输出: Promise 1 resolved
>  .catch(error => console.error(error)); // 捕获 Promise 3 rejected 的错误
>```
>
>在上面的示例中，Promise.race() 方法接收一个包含三个 Promise 对象的数组。由于 promise1 的解决速度最快，因此返回的 Promise 对象将会解决，并携带着 promise1 的解决值 "Promise 1 resolved"。promise2 和 promise3 的状态和结果将会被忽略，因为它们的解决和拒绝速度较慢。
>
>



## promise对象的finally方法

>
>
>`finally` 方法是 Promise 对象原型上的一个方法，它接受一个回调函数作为参数，并在 Promise 结束时（无论是 resolve 还是 reject）都会执行该回调函数。`finally` 方法的主要作用是在 Promise 完成后执行一些清理操作或必要的收尾工作。
>
>`finally` 方法的语法如下：
>```javascript
>promise.finally(onFinally);
>```
>其中，`promise` 是一个 Promise 对象，`onFinally` 是一个回调函数。
>
>无论 Promise 是被解决（resolved）还是被拒绝（rejected），`onFinally` 都会被调用。它没有任何参数，也不会影响 Promise 链的执行流程。如果在 `finally` 方法中返回一个新的 Promise 对象，它会在 `finally` 方法执行完后替换之前的 Promise 对象，并传递相同的解决（resolve）或拒绝（reject）状态。
>
>以下是一个使用 `finally` 方法的示例：
>```javascript
>function fetchData() {
>  return new Promise((resolve, reject) => {
>    // 模拟异步操作
>    setTimeout(() => {
>      const randomNumber = Math.random();
>      if (randomNumber < 0.5) {
>        resolve('Data retrieved successfully');
>      } else {
>        reject('Error retrieving data');
>      }
>    }, 1000);
>  });
>}
>
>fetchData()
>  .then((data) => {
>    console.log(data);
>  })
>  .catch((error) => {
>    console.error(error);
>  })
>  .finally(() => {
>    console.log('Cleanup');
>  });
>```
>
>在上面的例子中，不管 Promise 是成功还是失败，最后都会执行 `finally` 方法中的回调函数，并打印出 "Cleanup"。这样可以确保无论 Promise 结果如何，都可以执行一些必要的清理操作，比如关闭数据库连接、释放资源等。
>
>需要注意的是，`finally` 方法返回的是一个新的 Promise 对象，并且该对象的状态和值将取决于前面的 Promise 对象的状态和值。





## async关键字

用于声明一个函数为： 异步函数

>
>
>`async` 是 JavaScript 中的一个关键字，用于声明一个函数是异步函数。异步函数返回一个 Promise 对象，可以使用 `await` 关键字来等待 Promise 对象的解决，并暂停函数的执行，直到 Promise 对象解决或拒绝。
>
>异步函数的语法如下：
>```javascript
>async function functionName() {
>  // 异步操作
>  // 使用 await 等待 Promise 对象的解决或拒绝
>  // 其他操作
>  // 返回一个值或 Promise 对象
>}
>```
>
>异步函数可以包含多个 `await` 表达式，每个 `await` 表达式后面通常是一个返回 Promise 对象的异步操作，例如异步请求、读取文件等。当遇到 `await` 表达式时，函数的执行会暂停，直到该 `await` 表达式后面的 Promise 对象解决或拒绝，然后获取到解决的值并继续执行。
>
>以下是一个使用异步函数的示例：
>```javascript
>function fetchData() {
>  return new Promise((resolve, reject) => {
>    // 模拟异步操作
>    setTimeout(() => {
>      const randomNumber = Math.random();
>      if (randomNumber < 0.5) {
>        resolve('Data retrieved successfully');
>      } else {
>        reject('Error retrieving data');
>      }
>    }, 1000);
>  });
>}
>
>async function getData() {
>  try {
>    const data = await fetchData();
>    console.log(data);
>    return 'Success';
>  } catch (error) {
>    console.error(error);
>    throw new Error('Failed');
>  }
>}
>
>getData()
>  .then((result) => {
>    console.log(result);
>  })
>  .catch((error) => {
>    console.error(error);
>  });
>```
>
>在上面的例子中，`getData` 函数是一个异步函数，使用 `await` 等待 `fetchData` 函数返回的 Promise 对象解决或拒绝。当 Promise 解决时，获取到解决的值并打印出来。如果 Promise 拒绝，则抛出一个新的错误。
>
>异步函数使得处理异步操作变得更加直观和简单，通过 `await` 关键字可以以同步的方式编写异步代码。它可以帮助解决回调地狱和 Promise 链的问题，提供了更加优雅和可读性强的代码编写方式。



#### 拓展知识：语法糖

语法糖（Syntactic sugar）是指在编程语言中提供的一种便捷的语法形式，它并不改变语言的功能或特性，只是提供了一种更简洁、易读或符合直觉的写法。语法糖的存在使得代码的编写和阅读更加方便和舒适，减少了冗余的代码或复杂的语法结构。

语法糖通常是在编译或解释阶段被转换成语言本身的基本语法结构，实际执行的是等价的基本语法结构。它们的目的是提高开发效率和代码可读性，而不是引入新的功能。

一些常见的语法糖包括：

1. 箭头函数：箭头函数是一种更简洁的函数定义语法，可以减少函数声明的冗余代码。
2. 模板字面量：模板字面量（Template literals）提供了一种更方便的方式来拼接字符串和插入变量。
3. 解构赋值：解构赋值语法允许从数组或对象中提取值并赋给变量，减少了对每个属性进行单独赋值的冗余代码。
4. 简化的对象字面量：简化的对象字面量语法使得定义对象更加简洁，不再需要显式地写出属性和方法的键和值。
5. 迭代器和生成器：迭代器和生成器提供了一种更直观和可控的方式来遍历数据结构，减少了手动迭代的复杂性。
6. async/await：async/await 是用于处理异步操作的语法糖，提供了更直观和类似同步代码的方式来处理异步任务。

语法糖在语言设计中起到了简化和优化代码的作用，让开发人员能够更快速地编写出高效、易读的代码。它们不是必需的，但可以提升开发效率和代码质量。



### async关键字 - 异步函数内部使用await语句

在函数内部，`s` 的确是一个数组对象，而不是 Promise 对象。`await` 表达式会等待一个 Promise 对象的解析结果，并将其返回值赋给变量。在这种情况下，`await` 表达式等待的是一个被自动包装成 Promise 对象的字符串，所以它的返回值是字符串 "hello" 的数组形式。

在函数执行过程中，`await` 关键字会暂停函数的执行，等待 Promise 对象解析完成。这意味着函数会暂时停止，并等待 `await` 后面的表达式完成。当 `await` 后面的表达式完成后，函数会继续执行。

在这个例子中，当执行到 `let data = await s.split("");` 时，代码会等待 `s`（字符串 "hello" 的数组形式）的解析结果。一旦解析完成，结果就会赋值给 `data`，然后函数继续执行。

最终，函数 `f()` 返回一个 Promise 对象，其中的解析值是 `data`，也就是一个包含字符 "h", "e", "l", "l", "o" 的数组。这个 Promise 对象会被自动创建并返回，使得我们可以使用 `.then()` 方法来处理解析结果。



### async特点： 当有一个await后面promise为reject时，不再执行后续await语句

>
>
>在 `async` 函数中，`await` 关键字用于等待一个 Promise 的解析结果。如果 `await` 后面的 Promise 被拒绝（rejected），那么 `async` 函数的执行会暂停，并且后续的 `await` 语句不会执行。相当于发生了异常。
>
>这种特性可以让我们在处理异步操作时更加灵活地控制流程。当某个异步操作失败时，我们可以使用 `try/catch` 块来捕获异常并进行相应的处理。
>
>以下是一个示例：
>
>```javascript
>async function fetchData() {
>  try {
>    const result1 = await asyncOperation1(); // 第一个异步操作
>    const result2 = await asyncOperation2(); // 第二个异步操作
>    const result3 = await asyncOperation3(); // 第三个异步操作
>    // 执行成功
>  } catch (error) {
>    // 处理错误
>  }
>}
>```
>
>在上述示例中，如果任何一个异步操作发生错误并被拒绝，那么后续的异步操作将不会执行，而是跳转到 `catch` 块进行错误处理。
>
>





### 异步函数内部的try catch

   try {

​     await Promise.reject("出错了");

​    } catch (error) {}

​    return 

   }

当我们执行了内部try语句，即使内部有异常，当我们内部的catch语句为空代码块时，表示为**忽略该异常**

则返回为 return Promise.resolve("成功"); 语句

在外界只需要使用.then语句即可

当内部try中有多个await语句时，当执行异步函数异常时，会被catch，如果在catch选择将该异常抛出，那么该异常会被外界 .catch语句捕捉到，并对之处理



### 在async关键函数中去掉await

 console.log("开始执行");  

const result = await someAsyncOperation();  

console.log("异步操作完成，结果为:", result); 

 return "函数执行完毕";  

如果将await去掉会导致结果不同吗

会导致结果出错， 当去掉时，执行该语句时，不会等操作结果结束再执行下一句语句，当此异步操作所需时间比较长时，执行打印时，result为 undefined，导致实际所需结果与结果不一致出错。

>
>
>是的，将 `await` 去掉会导致结果不同。`await` 关键字用于暂停异步函数的执行，等待 Promise 对象的解析结果。如果将 `await` 去掉，代码将不会等待异步操作完成，而是直接执行下一行代码。
>
>在你提供的代码示例中：
>
>```javascript
>console.log("开始执行");
>const result = await someAsyncOperation();
>console.log("异步操作完成，结果为:", result);
>return "函数执行完毕";
>```
>
>如果你去掉 `await` 关键字，代码会立即执行 `someAsyncOperation()`，但不会等待它的结果。然后，代码会继续执行下一行，即 `console.log("异步操作完成，结果为:", result);` 和 `return "函数执行完毕";`。这可能导致结果的输出顺序不同，并且函数的返回值可能会受到未解析的 Promise 对象的影响。
>
>因此，`await` 关键字在异步函数中起着关键的作用，确保代码按照预期的顺序执行，并正确处理异步操作的结果。



## javaScript和java中类的异同

>JavaScript和Java中的类有一些相似之处，但也存在许多不同之处。以下是它们之间的主要异同点：
>
>相似之处：
>1. 类的定义：两者都使用类来定义对象的属性和行为，并通过类来创建对象的实例。
>2. 封装性：类可以用于实现封装，将属性和方法封装在类的内部，并提供公开的接口供外部访问。
>3. 继承：类可以通过继承机制创建子类，并继承父类的属性和方法。
>4. 多态性：类支持多态性，允许子类重写父类的方法，并根据对象的实际类型调用相应的方法。
>
>不同之处：
>1. 语言类型：JavaScript是一种动态类型的脚本语言，而Java是一种静态类型的编译型语言。
>2. 类型系统：JavaScript是基于原型的语言，而Java是基于类的语言。在JavaScript中，类是基于原型链的，而在Java中，类是通过定义和实例化来创建对象的。
>3. 类的成员访问：Java中的类可以使用访问修饰符（public、private、protected）来限制成员的访问权限，而JavaScript中的类中的属性和方法默认是公开的。
>4. 类的定义方式：JavaScript中的类定义比较灵活，可以使用类声明和类表达式两种方式，而Java中的类定义必须使用类声明。
>5. 静态成员：Java中的类可以定义静态成员（静态属性和方法），而JavaScript中的类不支持静态成员。
>
>总体上说，尽管JavaScript和Java中的类有一些相似之处，但由于它们是不同类型的语言，因此在语法、类型系统和语言特性等方面存在许多区别。了解这些差异可以帮助开发人员更好地理解和利用两种语言中的类的概念。



## Object.assign方法

`Object.assign()` 是 JavaScript 中的一个**静态方法**，用于将一个或多个源对象的属性复制到目标对象中。它的语法如下：

```javascript
Object.assign(target, ...sources)
```

其中，`target` 是目标对象，`sources` 是一个或多个源对象。`Object.assign()` 方法会将源对象的可枚举属性复制到目标对象中，并返回目标对象。

以下是一些 `Object.assign()` 的特点和用法：

1. `Object.assign()` 执行的是浅拷贝，即只复制对象的属性值，而不是复制对象的引用。
2. 如果目标对象中已经有相同属性名的属性，源对象中的属性值会覆盖目标对象中的属性值。
3. 如果传入的源对象为 `null` 或 `undefined`，`Object.assign()` 会跳过该源对象。
4. 如果传入的目标对象为基本类型（如字符串、数字等），`Object.assign()` 会将目标对象转换为包装对象，并复制源对象的属性到包装对象中。
5. `Object.assign()` 是浅拷贝，如果源对象的属性值是引用类型（如对象或数组），则复制的是引用，修改源对象中的属性会影响目标对象中对应的属性。

以下是一个简单的示例，展示了 `Object.assign()` 的使用：

```javascript
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };

const result = Object.assign(target, source);

console.log(result); // 输出: { a: 1, b: 3, c: 4 }
console.log(target); // 输出: { a: 1, b: 3, c: 4 }
```

在上面的例子中，`Object.assign()` 将 `source` 对象的属性复制到 `target` 对象中，并返回复制后的 `target` 对象。由于 `target` 对象中已经有一个名为 `b` 的属性，所以源对象中的 `b` 属性值将覆盖目标对象中的属性值。

需要注意的是，`Object.assign()` 只会复制源对象的可枚举属性，并且不会复制原型链上的属性。如果需要深拷贝对象或复制原型链上的属性，需要使用其他方法或工具库。



### 类内外部所定义的属性



类的属性也会被放置在原型链上。类的构造函数内部定义的属性会成为实例的自身属性，而在类外部定义的属性会成为原型链上的属性。



为类定义的属性会被放置于原型链中，而在constructor初始化所定义的属性，为实例的自身属性： 指每个实例都可以有自己一个副本，在生成时所定义的值,原型链中的属性，每个实例化对象都可以通过原型链获取值

>
>
>在 JavaScript 中，类的属性也会被放置在原型链上。类的构造函数内部定义的属性会成为实例的自身属性，而在类外部定义的属性会成为原型链上的属性。
>
>让我们通过一个例子来理解这句话：
>
>```javascript
>class MyClass {
>  constructor() {
>    this.instanceProperty = 'This is an instance property';
>  }
>
>  static staticProperty = 'This is a static property';
>}
>
>const myInstance = new MyClass();
>
>console.log(myInstance.instanceProperty); // 输出: This is an instance property
>console.log(MyClass.staticProperty); // 输出: This is a static property
>```
>
>在上面的例子中，我们定义了一个名为 `MyClass` 的类，并在构造函数内部定义了一个实例属性 `instanceProperty`。这个属性会成为实例对象自身的属性，每个实例都会拥有自己的副本。
>
>同时，我们使用静态属性的新语法将 `staticProperty` 定义为类的静态属性。静态属性是属于类本身的属性，而不是属于实例的。在类外部通过类名访问静态属性时，它会从原型链上获取该属性的值。
>
>所以，`instanceProperty` 是实例的自身属性，每个实例都有自己的副本；而 `staticProperty` 是属于类的属性，所有实例共享相同的值。
>
>需要注意的是，如果你在类外部直接定义一个属性，并将其赋值给类，这个属性会成为类的原型链上的属性：
>
>```javascript
>class MyClass {}
>
>MyClass.prototype.prototypeProperty = 'This is a prototype property';
>
>const myInstance = new MyClass();
>
>console.log(myInstance.prototypeProperty); // 输出: This is a prototype property
>```
>
>在上面的例子中，我们在类外部通过 `MyClass.prototype` 直接定义了一个属性 `prototypeProperty`，并将其赋值为 `'This is a prototype property'`。这个属性会成为类的原型链上的属性，可以被类的实例访问到。
>
>总结起来，类的属性也会被放置在原型链上。构造函数内部定义的属性是实例的自身属性，每个实例都有自己的副本；而在类外部定义的属性是原型链上的属性，被所有实例共享。
>
>





## 接口和模块的异同点

>
>
>异同点：
>- 相同点：
>  - 模块和接口都用于组织和封装代码，提供了一种抽象和分组的方式。
>  - 它们都可以定义方法和属性，并且可以被其他代码引用和实现。
>
>- 不同点：
>  - 语言环境：模块是在 JavaScript 环境中使用的概念，用于组织和管理代码文件；而接口是 Java 中的一种语言特性，用于定义类的行为和契约。
>  - 实现方式：模块通常是通过导出和导入语句来定义和使用的，可以在不同的文件中定义和引用；而接口是在类中使用 `implements` 关键字实现的，一个类可以实现多个接口。
>  - 范围和访问控制：模块可以定义公开（export）和私有（不导出）的成员，可以控制对外部代码的可见性；接口定义的方法和属性默认是公开的，并且可以在实现类中进行重写和实现。
>
>总体而言，模块和接口在某些方面有相似之处，但在语言环境、实现方式和范围控制等方面存在差异。它们各自在不同的语言中有着特定的用途和作用。



### 模块的导入和导出须在模块的顶层上下文

>
>
>确切地说，导入和导出语句需要在模块的顶层上下文中使用，而不是全局上下文。模块的顶层上下文是指模块文件的最外层，而不是整个应用程序的全局作用域。
>
>在模块的顶层上下文中，你可以使用导入语句来引入其他模块提供的功能，并使用导出语句将当前模块的功能暴露给其他模块使用。
>
>举个例子，假设我们有两个模块 `moduleA.js` 和 `moduleB.js`：
>
>moduleA.js:
>```javascript
>export const name = "Alice";
>```
>
>moduleB.js:
>```javascript
>import { name } from './moduleA';
>console.log(name); // 输出 "Alice"
>```
>
>在这个例子中，我们在 `moduleB.js` 的顶层上下文中使用了 `import` 语句来导入 `moduleA.js` 中导出的 `name` 变量。这个导入语句必须位于模块的顶层上下文中，而不是在函数或其他内部作用域中。
>
>所以，要正确使用模块化语法，你需要确保在模块的顶层上下文中编写导入和导出语句，这样才能正确加载和使用模块的功能。





## 导入默认模块时可以自定名字

因为文件导出时，只能导出一次默认对象。

默认导出是一种特殊的导出方式，表示模块的默认输出，它可以是一个对象、函数、类或其他任意值。

所以在导入时，不需要加{}, 且名字可以自定义，因为导出唯一性，故导入也具有唯一性，不需要指定



是的，可以在另一个文件中导入默认导出的模块。

假设我们有一个文件 `moduleA.js`，其中有一个默认导出的对象：

```javascript
// moduleA.js
export default {
  name: 'John',
  age: 30,
};
```

然后在另一个文件 `moduleB.js` 中，我们可以导入 `moduleA.js` 的默认导出：

```javascript
// moduleB.js
import myDefault from './moduleA.js';

console.log(myDefault.name); // 输出 'John'
console.log(myDefault.age); // 输出 30
```

在导入默认导出时，可以使用任意名称来接收导出的值（上述例子中的 `myDefault`）。这意味着导入的名称不必与导出时的名称相同。

需要注意的是，在导入默认导出时，不需要使用花括号 `{}`，因为默认导出只能有一个，而不需要指定导出的名称。





## 在浏览器无法导入本地模块的js文件

这个错误是由于浏览器的同源策略导致的，而不是浏览器的兼容性问题。同源策略是一种安全机制，旨在防止恶意脚本通过跨域请求获取用户的敏感信息。

同源策略要求脚本只能从相同的协议、域名和端口加载资源。因此，当你尝试从本地文件系统加载脚本文件时，浏览器会阻止这个操作，因为本地文件系统的协议是`file://`，与常用的http或https协议不同。

解决这个问题的常见方法是将你的代码和脚本部署到一个支持http或https协议的服务器上，并通过访问服务器的URL来加载脚本文件。这样就符合同源策略的要求，浏览器就不会阻止加载操作了。

需要注意的是，这个问题只在浏览器中出现，而在实际部署到服务器上时通常不会遇到这个问题。所以在开发阶段，可以使用本地服务器或其他工具来模拟一个服务器环境，以便测试和调试你的代码。

















